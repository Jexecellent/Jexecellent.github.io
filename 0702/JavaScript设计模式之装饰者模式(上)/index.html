<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css"><meta name="keywords" content="js,设计模式,decorator,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2"><meta name="description" content="在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变;另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。"><meta name="keywords" content="js,设计模式,decorator"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript设计模式之装饰者模式(上)"><meta property="og:url" content="https://jexecellent.github.io/0702/JavaScript设计模式之装饰者模式(上)/index.html"><meta property="og:site_name" content="Bean"><meta property="og:description" content="在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变;另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://out2pv7xu.bkt.clouddn.com/decorator1-1.png"><meta property="og:image" content="http://out2pv7xu.bkt.clouddn.com/decorator1-2.png"><meta property="og:updated_time" content="2018-07-02T07:01:17.340Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaScript设计模式之装饰者模式(上)"><meta name="twitter:description" content="在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变;另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。"><meta name="twitter:image" content="http://out2pv7xu.bkt.clouddn.com/decorator1-1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://jexecellent.github.io/0702/JavaScript设计模式之装饰者模式(上)/"><title>JavaScript设计模式之装饰者模式(上) | Bean - Just do it</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Bean</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://jexecellent.github.io/0702/JavaScript设计模式之装饰者模式(上)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Bean Liu"><meta itemprop="description" content=""><meta itemprop="image" content="/images/tou.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Bean"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JavaScript设计模式之装饰者模式(上)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T15:01:17+08:00">2018-07-02</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变;另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。</p><a id="more"></a><p>使用继承还会带来另外一个问题，在完成一些功能复用的同时，有可能创建出大量的子类，使子类的数量呈爆炸性增长。如何避免这类问题的发生了？首先想到的是这些对象可不可以动态的添加职责呢？答案是肯定的；</p><p>像这种给对象动态地增加职责的方式称为装饰者（decorator）模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式，比如天冷了就多穿一件外套；</p><h3 id="模拟传统面向对象语言的装饰者模式"><a href="#模拟传统面向对象语言的装饰者模式" class="headerlink" title="模拟传统面向对象语言的装饰者模式"></a>模拟传统面向对象语言的装饰者模式</h3><p>首先要提出来的是，作为一门解释执行的语言，给 JavaScript中的对象动态添加或者改变职责是一件再简单不过的事情，虽然这种做法改动了对象自身，跟传统定义中的装饰者式并不一样，但这无疑更符合 JavaScript 的语言特色。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    name: <span class="string">'sven'</span>,</div><div class="line">    address: <span class="string">'深圳市'</span></div><div class="line">&#125;;</div><div class="line">obj.address = obj.address + <span class="string">'福田区'</span>;</div></pre></td></tr></table></figure><p>传统面向对象语言中的装饰者模式在 JavaScript中适用的场景并不多，如上面代码所示，通常我们并不太介意改动对象自身。尽管如此，本节我们还是稍微模拟一下传统面向对象语言中的装饰者模式实现。</p><p>假设我们在编写一个飞机大战的游戏，随着经验值的增加，我们操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹。</p><p>下面来看代码实现，首先是原始的飞机类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Plane = function() &#123;&#125; </div><div class="line">Plane.prototype.fire= function() &#123;</div><div class="line">   console.log(&apos;发射普通的子弹&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来增加两个装饰类，分别是导弹和原子弹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var MissileDecorator = function( plane )&#123;</div><div class="line">  this.plane = plane;</div><div class="line">&#125; </div><div class="line">MissileDecorator.prototype.fire = function()&#123;</div><div class="line">  this.plane.fire();</div><div class="line">  console.log( &apos;发射导弹&apos; );</div><div class="line">&#125; </div><div class="line">var AtomDecorator = function( plane )&#123;</div><div class="line">  this.plane = plane;</div><div class="line">&#125;</div><div class="line">AtomDecorator.prototype.fire = function()&#123;</div><div class="line">  this.plane.fire();</div><div class="line">  console.log( &apos;发射原子弹&apos; );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>导弹类和原子弹类的构造函数都接受参数 plane 对象，并且保存好这个参数，在它们的 fire方法中，除了执行自身的操作之外，还调用 plane 对象的 fire 方法。</p><p>这种给对象动态增加职责的方式，并没有真正地改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口（fire方法），当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。</p><p>因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象。</p><p><img src="http://out2pv7xu.bkt.clouddn.com/decorator1-1.png" alt="decorator1-1"></p><p>最后看看测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var plane = new Plane();</div><div class="line">plane = new MissileDecorator( plane );</div><div class="line">plane = new AtomDecorator( plane );</div><div class="line">plane.fire(); // 分别输出： 发射普通子弹、发射导弹、发射原子弹</div></pre></td></tr></table></figure><h3 id="装饰者也是包装器"><a href="#装饰者也是包装器" class="headerlink" title="装饰者也是包装器"></a>装饰者也是包装器</h3><p>在《设计模式》成书之前，GoF 原想把装饰者（decorator）模式称为包装器（wrapper）模式。</p><p>从功能上而言，decorator 能很好地描述这个模式，但从结构上看，wrapper 的说法更加贴切。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链依次传递到所有的对象，每个对象都有处理这条请求的机会。</p><p><img src="http://out2pv7xu.bkt.clouddn.com/decorator1-2.png" alt="decorator1-1"></p><h3 id="JavaScript-的装饰者"><a href="#JavaScript-的装饰者" class="headerlink" title="JavaScript 的装饰者"></a>JavaScript 的装饰者</h3><p>JavaScript语言动态改变对象相当容易，我们可以直接改写对象或者对象的某个方法，并不需要使用“类”来实现装饰者模式，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var plane = &#123;</div><div class="line"> fire: function()&#123;</div><div class="line">   console.log( &apos;发射普通子弹&apos; );</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">var missileDecorator = function()&#123;</div><div class="line"> console.log( &apos;发射导弹&apos; );</div><div class="line">&#125;</div><div class="line">var atomDecorator = function()&#123;</div><div class="line"> console.log( &apos;发射原子弹&apos; );</div><div class="line">&#125;</div><div class="line">var fire1 = plane.fire;</div><div class="line">plane.fire = function()&#123;</div><div class="line"> fire1();</div><div class="line"> missileDecorator();</div><div class="line">&#125;</div><div class="line">var fire2 = plane.fire;</div><div class="line">plane.fire = function()&#123;</div><div class="line"> fire2();</div><div class="line"> atomDecorator();</div><div class="line">&#125;</div><div class="line">plane.fire(); // 分别输出： 发射普通子弹、发射导弹、发射原子弹</div></pre></td></tr></table></figure><h3 id="装饰函数"><a href="#装饰函数" class="headerlink" title="装饰函数"></a>装饰函数</h3><p>JavaScript 中，几乎一切都是对象，其中函数又被称为一等对象。在平时的开发工作中，也许大部分时间都在和函数打交道。在 JavaScript 中可以很方便地给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能。在代码的运行期间，我们很难切入某个函数的执行环境。</p><p>要想为函数添加一些功能，最简单粗暴的方式就是直接改写该函数，但这是最差的办法，直接违反了开放封闭原则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = function()&#123;</div><div class="line"> alert (1);</div><div class="line">&#125; </div><div class="line">// 改成：</div><div class="line">var a = function()&#123;</div><div class="line"> alert (1);</div><div class="line"> alert (2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>很多时候我们不想去碰原函数，也许原函数是由其他同事编写的，里面的实现非常杂乱。甚至在一个古老的项目中，这个函数的源代码被隐藏在一个我们不愿碰触的阴暗角落里。现在需要一个办法，在不改变函数源代码的情况下，能给函数增加功能，这正是开放封闭原则给我们指出的光明道路。</p><p>其实在上面的代码中，我们已经找到了一种答案，通过保存原引用的方式就可以改写某个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = function()&#123;</div><div class="line"> alert (1);</div><div class="line">&#125;</div><div class="line">var _a = a;</div><div class="line">a = function()&#123;</div><div class="line"> _a();</div><div class="line"> alert (2);</div><div class="line">&#125;</div><div class="line">a();</div></pre></td></tr></table></figure><p>这是实际开发中很常见的一种做法，比如我们想给 window 绑定 onload 事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的 window.onload 函数中的行为，我们一般都会先保存好原先的 window.onload，把它放入新的 window.onload 里执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.onload = function()&#123;</div><div class="line"> alert (1);</div><div class="line">&#125;</div><div class="line">var _onload = window.onload || function()&#123;&#125;;</div><div class="line">window.onload = function()&#123;</div><div class="line"> _onload();</div><div class="line"> alert (2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样的代码当然是符合开放封闭原则的，我们在增加新功能的时候，确实没有修改原来的window.onload 代码，但是这种方式存在以下两个问题。</p><ul><li><p>必须维护_onload 这个中间变量，虽然看起来并不起眼，但如果函数的装饰链较长，或者<br>需要装饰的函数变多，这些中间变量的数量也会越来越多。</p></li><li><p>其实还遇到了 this 被劫持的问题，在 window.onload 的例子中没有这个烦恼，是因为调用普通函数_onload 时，this 也指向 window，跟调用 window.onload 时一样（函数作为对象的方法被调用时，this 指向该对象，所以此处 this 也只指向 window）。现在把 window.onload换成document.getElementById，代码如下:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var _getElementById = document.getElementById;</div><div class="line">document.getElementById = function( id )&#123;</div><div class="line"> alert (1);</div><div class="line"> return _getElementById( id ); // (1)</div><div class="line">&#125;</div><div class="line">var button = document.getElementById( &apos;button&apos; );</div></pre></td></tr></table></figure><p>执行这段代码，我们看到在弹出 alert(1)之后，紧接着控制台抛出了异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 输出： Uncaught TypeError: Illegal invocation</div></pre></td></tr></table></figure><p>异常发生在(1) 处的_getElementById( id )这句代码上，此时_getElementById 是一个全局函数，当调用一个全局函数时，this 是指向 window 的，而 document.getElementById 方法的内部实现需要使用 this 引用，this 在这个方法内预期是指向 document，而不是 window, 这是错误发生的原因，所以使用现在的方式给函数增加功能并不保险。</p><p>改进后的代码可以满足需求，我们要手动把 document 当作上下文 this 传入_getElementById：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line"> &lt;button id=&quot;button&quot;&gt;&lt;/button&gt;</div><div class="line"> &lt;script&gt;</div><div class="line">  var _getElementById = document.getElementById;</div><div class="line">  document.getElementById = function()&#123;</div><div class="line">    alert (1);</div><div class="line">    return _getElementById.apply( document, arguments );</div><div class="line">  &#125;</div><div class="line">  var button = document.getElementById( &apos;button&apos; );</div><div class="line"> &lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>但这样做显然很不方便，下面我们引入AOP，来提供一种完美的方法给函数动态增加功能。</p><h3 id="用-AOP-装饰函数"><a href="#用-AOP-装饰函数" class="headerlink" title="用 AOP 装饰函数"></a>用 AOP 装饰函数</h3><p>首先给出 Function.prototype.before 方法和 Function.prototype.after 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Function.prototype.before = function( beforefn )&#123;</div><div class="line"> var __self = this; // 保存原函数的引用</div><div class="line"> return function()&#123; // 返回包含了原函数和新函数的&quot;代理&quot;函数</div><div class="line">    beforefn.apply( this, arguments ); // 执行新函数，且保证 this 不被劫持，新函数接受的参数</div><div class="line">    // 也会被原封不动地传入原函数，新函数在原函数之前执行</div><div class="line">    return __self.apply( this, arguments ); //执行原函数并返回原函数的执行结果，</div><div class="line">        // 并且保证 this 不被劫持</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">Function.prototype.after = function( afterfn )&#123;</div><div class="line">    var __self = this;</div><div class="line">    return function()&#123;``</div><div class="line">        var ret = __self.apply( this, arguments );</div><div class="line">        afterfn.apply( this, arguments );</div><div class="line">        return ret;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>Function.prototype.before 接受一个函数当作参数，这个函数即为新添加的函数，它装载了新添加的功能代码。</p><p>接下来把当前的 this 保存起来，这个 this 指向原函数，然后返回一个“代理”函数，这个“代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行（前置装饰），这样就实现了动态装饰的效果。</p><p>我们注意到，通过 Function.prototype.apply 来动态传入正确的 this，保证了函数在被装饰之后，this 不会被劫持。</p><p>Function.prototype.after 的原理跟 Function.prototype.before 一模一样，唯一不同的地方在于让新添加的函数在原函数执行之后再执行。</p><p>下面来试试用 Function.prototype.before 的威力：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line"> &lt;button id=&quot;button&quot;&gt;&lt;/button&gt;</div><div class="line"> &lt;script&gt;</div><div class="line">    Function.prototype.before = function( beforefn )&#123;</div><div class="line">        var __self = this;</div><div class="line">        return function()&#123;</div><div class="line">            beforefn.apply( this, arguments );</div><div class="line">            return __self.apply( this, arguments );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    document.getElementById = document.getElementById.before(function()&#123;</div><div class="line">        alert (1);</div><div class="line">    &#125;);</div><div class="line">    var button = document.getElementById( &apos;button&apos; ); </div><div class="line">    console.log( button );</div><div class="line"> &lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>再回到 window.onload 的例子，看看用 Function.prototype.before 来增加新的 window.onload事件是多么简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">window.onload = function()&#123;</div><div class="line"> alert (1);</div><div class="line">&#125;</div><div class="line">window.onload = ( window.onload || function()&#123;&#125; ).after(function()&#123;</div><div class="line"> alert (2);</div><div class="line">&#125;).after(function()&#123;</div><div class="line"> alert (3);</div><div class="line">&#125;).after(function()&#123;</div><div class="line"> alert (4);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>值得提到的是，上面的 AOP 实现是在 Function.prototype 上添加 before 和 after 方法，但许多人不喜欢这种污染原型的方式，那么我们可以做一些变通，把原函数和新函数都作为参数传入before 或者 after 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var before = function( fn, beforefn )&#123;</div><div class="line"> return function()&#123;</div><div class="line">   beforefn.apply( this, arguments );</div><div class="line">   return fn.apply( this, arguments );</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">var a = before(</div><div class="line"> function()&#123;alert (3)&#125;,</div><div class="line"> function()&#123;alert (2)&#125;</div><div class="line">);</div><div class="line">a = before( a, function()&#123;alert (1);&#125; );</div><div class="line">a();</div></pre></td></tr></table></figure><p>下一节 ：AOP 的应用实例</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/js/" rel="tag"><i class="fa fa-tag"></i> &nbsp;&nbsp;js</a><a href="/tags/设计模式/" rel="tag"><i class="fa fa-tag"></i> &nbsp;&nbsp;设计模式</a><a href="/tags/decorator/" rel="tag"><i class="fa fa-tag"></i> &nbsp;&nbsp;decorator</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/0702/JavaScript中双叹号(!!)作用/" rel="next" title="JavaScript中双叹号(!!)作用"><i class="fa fa-chevron-left"></i> JavaScript中双叹号(!!)作用</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/0702/JavaScript设计模式之装饰者模式(下)/" rel="prev" title="JavaScript设计模式之装饰者模式(下)">JavaScript设计模式之装饰者模式(下)<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/tou.jpg" alt="Bean Liu"><p class="site-author-name" itemprop="name">Bean Liu</p><p class="site-description motion-element" itemprop="description">学无止境 宁静致远</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">14</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">13</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Jexecellent" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://www.cnblogs.com/qcxc/" title="浅葱小唱" target="_blank">浅葱小唱</a></li><li class="links-of-blogroll-item"> <a href="http://echizen.github.io/" title="blog" target="_blank">blog</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟传统面向对象语言的装饰者模式"><span class="nav-number">1.</span> <span class="nav-text">模拟传统面向对象语言的装饰者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰者也是包装器"><span class="nav-number">2.</span> <span class="nav-text">装饰者也是包装器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-的装饰者"><span class="nav-number">3.</span> <span class="nav-text">JavaScript 的装饰者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰函数"><span class="nav-number">4.</span> <span class="nav-text">装饰函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-AOP-装饰函数"><span class="nav-number">5.</span> <span class="nav-text">用 AOP 装饰函数</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Bean Liu</span></div><div class="powered-by"> 学海无涯苦作舟</div> <span class="post-meta-divider">|</span><div class="theme-info"> 主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank">NexT.Mist</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script></body></html>